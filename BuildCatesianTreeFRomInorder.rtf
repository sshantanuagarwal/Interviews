{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0   /**\
\
Given an inorder traversal of a cartesian tree, construct the tree.\
\
Cartesian tree :  is a heap ordered binary tree, where the root is greater than all the elements in the subtree.\
\
Note: You may assume that duplicates do not exist in the tree.\
\
Example :\
\
Input : [1 2 3]\
\
Left root right\
\
	2 \
/	\\\
1  3\
\
\
Return :   \
          3\
         /\
        2\
       /\
      1\
      \
 * Definition for binary tree\
 * class TreeNode \{\
 *     int val;\
 *     TreeNode left;\
 *     TreeNode right;\
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) \{\}\
 * \};\
 */\
\
class Heap \{\
  int findMax( int[] A, start, end) \{\
    if(start > end ) \
      return -1;\
    int max = INTEGER.MIN_VALUE;\
    index = -1;\
    for(int i = start; i <= end; i++) \{\
      if(A[i] > max) \{\
        max = A[i];\
        index = i;\
      \}\
    \}\
    return index;\
  \}\
\
   TreeNode buildCartesianTreeRec(TreeNode root, int[] A, start, end, index) \{	 \
     if(start>end) return null;\
     int leftindex = findMax(A,start,index-1);\
     root.left = TreeNode(A[leftindex]);\
     \
     int rightindex = findMax(A,index+1,end);\
     root.right = TreeNode(A[rightindex]);\
       \
     buildCartesianTreeRec(root.left, A, start, index-1, leftindex );\
     buildCartesianTreeRec(root.right, A, index+1, end, rightindex);\
     return root;\
   \}\
\
   TreeNode buildCartesianTree(int[] A) \{\
     if(A.length==0) return null;\
\
     int index = findMax(A,0,A.length-1);\
     TreeNode root = new TreeNode(A[index]);\
     buildCartesianTreeRec(root, A, start, A.length-1, index);\
\
   \}\
\}}